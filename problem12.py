## The sequence of triangle numbers is generated by adding the natural numbers. 
## So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
## 
## 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
## 
## Let us list the factors of the first seven triangle numbers:
## 
##  1: 1
##  3: 1,3
##  6: 1,2,3,6
## 10: 1,2,5,10
## 15: 1,3,5,15
## 21: 1,3,7,21
## 28: 1,2,4,7,14,28
## We can see that 28 is the first triangle number to have over five divisors.
## 
## What is the value of the first triangle number to have over five hundred divisors?

import sys

cache = {} ## We store known factorials.
cache_hits = 0
cache_miss = 0

FOO = [1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 14, 15, 16, 20, 21, 22, 24, 28, 30, 32, 33, 35, 40, 42, 44, 48, 55, 56, 60, 64, 66, 70, 77, 80, 84, 88, 96, 105, 110, 112, 120, 132, 140, 154, 160, 165, 168, 176, 192, 210, 220, 224, 231, 240, 264, 280, 308, 320, 330, 336, 352, 385, 420, 440, 448, 462, 480, 528, 560, 616, 660, 672, 704, 770, 840, 880, 924, 960, 1056, 1120, 1155, 1232, 1320, 1344, 1540, 1680, 1760, 1848, 2112, 2240, 2310, 2464, 2640, 3080, 3360, 3520, 3696, 4620, 4928, 5280, 6160, 6720, 7392, 9240, 10560, 12320, 14784, 18480, 24640, 36960, 73920]

def factorize(n):    
    return set(reduce(list.__add__, 
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))

def cache_hit_rate():
	total = cache_hits + cache_miss
	if total == 0:
		return 0
	return 100*float(cache_hits)/float(total)


triangle = 1
next = 2

def reset_triangle():
	global triangle
	global next
	triangle = 1
	next = 2

def next_triangle():
	global triangle
	global next

	ret = triangle
	triangle = triangle + next
	next = next + 1
	return ret

def to_str(list_or_iterator):
	return "[" + ", ".join( str(x) for x in list_or_iterator) + "]"

def search(max_length):
	reset_triangle()

	factors = []
	max_so_far = 0
	
	while True:
		triangle = next_triangle()
		factors = factorize(triangle)
		length = len(factors)
		## print "%d => %s (%f%%)" % (triangle, to_str(factors), cache_hit_rate())
		
		if length > max_so_far:
			print "%d (%f%%)" % (length, cache_hit_rate())	
			max_so_far = length
		if length >= max_length:
			break
		
	return factors

def get_closest_triangle(nbr):
	reset_triangle()
	while True:
		t = next_triangle()
		if t >= nbr:
			return t

if __name__ == '__main__':
	target = int(sys.argv[1])
	f = list(search(target))
	## f = factorize(target)
	f.sort()
	print f
